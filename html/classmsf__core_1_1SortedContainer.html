<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>msf - modular sensor fusion: msf_core::SortedContainer&lt; T, PrototypeInvalidT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">msf - modular sensor fusion
   </div>
   <div id="projectbrief">Time delay compensated single and multi sensor fusion framework based on an EKF</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>msf_core</b></li><li class="navelem"><a class="el" href="classmsf__core_1_1SortedContainer.html">SortedContainer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classmsf__core_1_1SortedContainer-members.html">List of all members</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">msf_core::SortedContainer&lt; T, PrototypeInvalidT &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Manages a sorted container with strict less than ordering used to store state and measurement objects which can then be queried for closest states/measurements to a given time instant.  
 <a href="classmsf__core_1_1SortedContainer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="msf__sortedContainer_8h_source.html">msf_sortedContainer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0dd7e9676bf540e11f526a8ac16da06b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0dd7e9676bf540e11f526a8ac16da06b"></a>
typedef shared_ptr&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Ptr_T</b></td></tr>
<tr class="memitem:ac060dafe3a40d73ef6d35f4be7e0213e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac060dafe3a40d73ef6d35f4be7e0213e"></a>
typedef ListT::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>iterator_T</b></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9c72942ce59c634559fe7e226b6ab302"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsf__core_1_1SortedContainer.html#a9c72942ce59c634559fe7e226b6ab302">getInvalid</a> ()</td></tr>
<tr class="memdesc:a9c72942ce59c634559fe7e226b6ab302"><td class="mdescLeft">&#160;</td><td class="mdescRight">To be called to signal that a request could not be satisfied.  <a href="#a9c72942ce59c634559fe7e226b6ab302"></a><br/></td></tr>
<tr class="memitem:aea65ad1ff460ab46445b433ea3db49b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea65ad1ff460ab46445b433ea3db49b1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsf__core_1_1SortedContainer.html#aea65ad1ff460ab46445b433ea3db49b1">clear</a> ()</td></tr>
<tr class="memdesc:aea65ad1ff460ab46445b433ea3db49b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the internal container, dropping all the contents. <br/></td></tr>
<tr class="memitem:af51c989973b49002e737190cec67b6b4"><td class="memItemLeft" align="right" valign="top">ListT::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsf__core_1_1SortedContainer.html#af51c989973b49002e737190cec67b6b4">size</a> ()</td></tr>
<tr class="memdesc:af51c989973b49002e737190cec67b6b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the internal container.  <a href="#af51c989973b49002e737190cec67b6b4"></a><br/></td></tr>
<tr class="memitem:a8e6ef89431cbcac53439b580a7b8706c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e6ef89431cbcac53439b580a7b8706c"></a>
ListT::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsf__core_1_1SortedContainer.html#a8e6ef89431cbcac53439b580a7b8706c">insert</a> (const shared_ptr&lt; T &gt; &amp;value)</td></tr>
<tr class="memdesc:a8e6ef89431cbcac53439b580a7b8706c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an object to the internal container to the position not violating the internal strict less than ordering by time. <br/></td></tr>
<tr class="memitem:a66c37f04293ec2b3e2fae69ff2ac498e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66c37f04293ec2b3e2fae69ff2ac498e"></a>
ListT::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsf__core_1_1SortedContainer.html#a66c37f04293ec2b3e2fae69ff2ac498e">getIteratorBegin</a> ()</td></tr>
<tr class="memdesc:a66c37f04293ec2b3e2fae69ff2ac498e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the iterator at the beginning of the internal container. <br/></td></tr>
<tr class="memitem:a17fa1667d94905e8def74a65002907ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17fa1667d94905e8def74a65002907ed"></a>
ListT::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsf__core_1_1SortedContainer.html#a17fa1667d94905e8def74a65002907ed">getIteratorBeforeBegin</a> ()</td></tr>
<tr class="memdesc:a17fa1667d94905e8def74a65002907ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the iterator before the beginning of the internal container. <br/></td></tr>
<tr class="memitem:af1b1597192ac889cc918d8516cd6345c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1b1597192ac889cc918d8516cd6345c"></a>
ListT::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsf__core_1_1SortedContainer.html#af1b1597192ac889cc918d8516cd6345c">getIteratorEnd</a> ()</td></tr>
<tr class="memdesc:af1b1597192ac889cc918d8516cd6345c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the iterator at the end of the internal container. <br/></td></tr>
<tr class="memitem:a3ca27ff6fae8916a88a6690b9c8365a9"><td class="memItemLeft" align="right" valign="top">ListT::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsf__core_1_1SortedContainer.html#a3ca27ff6fae8916a88a6690b9c8365a9">getIteratorAtValue</a> (const shared_ptr&lt; T &gt; &amp;value, bool warnIfNotExistant=true)</td></tr>
<tr class="memdesc:a3ca27ff6fae8916a88a6690b9c8365a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the iterator at the specific time instant of the supplied object or an invalid object if the request cannot be satisfied.  <a href="#a3ca27ff6fae8916a88a6690b9c8365a9"></a><br/></td></tr>
<tr class="memitem:a727a60e4eb00ab45b2a39c8c069d2fcf"><td class="memItemLeft" align="right" valign="top">ListT::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsf__core_1_1SortedContainer.html#a727a60e4eb00ab45b2a39c8c069d2fcf">getIteratorAtValue</a> (const double &amp;time, bool warnIfNotExistant=true)</td></tr>
<tr class="memdesc:a727a60e4eb00ab45b2a39c8c069d2fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the iterator at a specific time instant or an invalid object if the request cannot be satisfied.  <a href="#a727a60e4eb00ab45b2a39c8c069d2fcf"></a><br/></td></tr>
<tr class="memitem:a4cbd2aeae2f6dde2dfd0dceea4a8e928"><td class="memItemLeft" align="right" valign="top">ListT::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsf__core_1_1SortedContainer.html#a4cbd2aeae2f6dde2dfd0dceea4a8e928">getIteratorClosestBefore</a> (const double &amp;statetime)</td></tr>
<tr class="memdesc:a4cbd2aeae2f6dde2dfd0dceea4a8e928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the iterator closest before a specific time instant.  <a href="#a4cbd2aeae2f6dde2dfd0dceea4a8e928"></a><br/></td></tr>
<tr class="memitem:a3c1f848e9874f9bdc4ab12645e699fcf"><td class="memItemLeft" align="right" valign="top">ListT::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsf__core_1_1SortedContainer.html#a3c1f848e9874f9bdc4ab12645e699fcf">getIteratorClosestAfter</a> (const double &amp;statetime)</td></tr>
<tr class="memdesc:a3c1f848e9874f9bdc4ab12645e699fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the iterator closest after a specific time instant.  <a href="#a3c1f848e9874f9bdc4ab12645e699fcf"></a><br/></td></tr>
<tr class="memitem:a64ce9fdfdd6220f78187e7270f689f02"><td class="memItemLeft" align="right" valign="top">ListT::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsf__core_1_1SortedContainer.html#a64ce9fdfdd6220f78187e7270f689f02">getIteratorClosest</a> (const double &amp;statetime)</td></tr>
<tr class="memdesc:a64ce9fdfdd6220f78187e7270f689f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the iterator closest to a specific time instant.  <a href="#a64ce9fdfdd6220f78187e7270f689f02"></a><br/></td></tr>
<tr class="memitem:ad027825ff0a1360acbe6b9c60f708cd9"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsf__core_1_1SortedContainer.html#ad027825ff0a1360acbe6b9c60f708cd9">getClosestBefore</a> (const double &amp;statetime)</td></tr>
<tr class="memdesc:ad027825ff0a1360acbe6b9c60f708cd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the closest object before a specific time instant.  <a href="#ad027825ff0a1360acbe6b9c60f708cd9"></a><br/></td></tr>
<tr class="memitem:a1bf7a97e06b2dd5bc2b6588dcb6799b8"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsf__core_1_1SortedContainer.html#a1bf7a97e06b2dd5bc2b6588dcb6799b8">getClosestAfter</a> (const double &amp;statetime)</td></tr>
<tr class="memdesc:a1bf7a97e06b2dd5bc2b6588dcb6799b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the closest after a specific time instant or an invalid object if the request cannot be satisfied.  <a href="#a1bf7a97e06b2dd5bc2b6588dcb6799b8"></a><br/></td></tr>
<tr class="memitem:aa0de5fa4d79a266a36556b67252a7d34"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsf__core_1_1SortedContainer.html#aa0de5fa4d79a266a36556b67252a7d34">getValueAt</a> (const double &amp;statetime)</td></tr>
<tr class="memdesc:aa0de5fa4d79a266a36556b67252a7d34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the object at a specific time instant or an invalid object if the request cannot be satisfied.  <a href="#aa0de5fa4d79a266a36556b67252a7d34"></a><br/></td></tr>
<tr class="memitem:ab262e5e5904b047df44110c1d05babdc"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsf__core_1_1SortedContainer.html#ab262e5e5904b047df44110c1d05babdc">getClosest</a> (const double &amp;statetime)</td></tr>
<tr class="memdesc:ab262e5e5904b047df44110c1d05babdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the closest to a specific time instant.  <a href="#ab262e5e5904b047df44110c1d05babdc"></a><br/></td></tr>
<tr class="memitem:aa2e690d22ea362eeb281ce30a96751d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsf__core_1_1SortedContainer.html#aa2e690d22ea362eeb281ce30a96751d5">clearOlderThan</a> (double age)</td></tr>
<tr class="memdesc:aa2e690d22ea362eeb281ce30a96751d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all objects having a time stamp older than the supplied time in seconds.  <a href="#aa2e690d22ea362eeb281ce30a96751d5"></a><br/></td></tr>
<tr class="memitem:ada83f9baa4b17b5816975b1e67354ff1"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsf__core_1_1SortedContainer.html#ada83f9baa4b17b5816975b1e67354ff1">getLast</a> ()</td></tr>
<tr class="memdesc:ada83f9baa4b17b5816975b1e67354ff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the last object in the container or an invalid object if the container is empty.  <a href="#ada83f9baa4b17b5816975b1e67354ff1"></a><br/></td></tr>
<tr class="memitem:a7cce297c5a4bbf80d617741fe3dc902e"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsf__core_1_1SortedContainer.html#a7cce297c5a4bbf80d617741fe3dc902e">getFirst</a> ()</td></tr>
<tr class="memdesc:a7cce297c5a4bbf80d617741fe3dc902e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the first object in the container or an invalid object if the container is empty.  <a href="#a7cce297c5a4bbf80d617741fe3dc902e"></a><br/></td></tr>
<tr class="memitem:a7e4c594bb1aec9d6d4d8fb73e7baff9a"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsf__core_1_1SortedContainer.html#a7e4c594bb1aec9d6d4d8fb73e7baff9a">updateTime</a> (double timeOld, double timeNew) __attribute__((warn_unused_result))</td></tr>
<tr class="memdesc:a7e4c594bb1aec9d6d4d8fb73e7baff9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function updates the time of an object in the container this function effectively changes the map ordering, so the previous iterators are invalidated the attribute unused can be eliminated for non gcc compilers, its just a little more verbose in cases where the updated value is not used.  <a href="#a7e4c594bb1aec9d6d4d8fb73e7baff9a"></a><br/></td></tr>
<tr class="memitem:a7cecf8583999a5b457e04d5ef781dc5d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsf__core_1_1SortedContainer.html#a7cecf8583999a5b457e04d5ef781dc5d">echoBufferContentTimes</a> ()</td></tr>
<tr class="memdesc:a7cecf8583999a5b457e04d5ef781dc5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debug output the contents of the container in a human readable time format.  <a href="#a7cecf8583999a5b457e04d5ef781dc5d"></a><br/></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename PrototypeInvalidT = T&gt;<br/>
class msf_core::SortedContainer&lt; T, PrototypeInvalidT &gt;</h3>

<p>Manages a sorted container with strict less than ordering used to store state and measurement objects which can then be queried for closest states/measurements to a given time instant. </p>
</div><h2>Member Function Documentation</h2>
<a class="anchor" id="aa2e690d22ea362eeb281ce30a96751d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename PrototypeInvalidT = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmsf__core_1_1SortedContainer.html">msf_core::SortedContainer</a>&lt; T, PrototypeInvalidT &gt;::clearOlderThan </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>age</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears all objects having a time stamp older than the supplied time in seconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>The maximum age of states in the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>shared pointer of the object. </dd></dl>

</div>
</div>
<a class="anchor" id="a7cecf8583999a5b457e04d5ef781dc5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename PrototypeInvalidT = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classmsf__core_1_1SortedContainer.html">msf_core::SortedContainer</a>&lt; T, PrototypeInvalidT &gt;::echoBufferContentTimes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Debug output the contents of the container in a human readable time format. </p>
<dl class="section return"><dt>Returns</dt><dd>String of the buffer contents with line breaks after every entry. </dd></dl>

</div>
</div>
<a class="anchor" id="ab262e5e5904b047df44110c1d05babdc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename PrototypeInvalidT = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;T&gt;&amp; <a class="el" href="classmsf__core_1_1SortedContainer.html">msf_core::SortedContainer</a>&lt; T, PrototypeInvalidT &gt;::getClosest </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>statetime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the closest to a specific time instant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>The time where we want to get the value at. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>shared pointer of the object. </dd></dl>

</div>
</div>
<a class="anchor" id="a1bf7a97e06b2dd5bc2b6588dcb6799b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename PrototypeInvalidT = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;T&gt;&amp; <a class="el" href="classmsf__core_1_1SortedContainer.html">msf_core::SortedContainer</a>&lt; T, PrototypeInvalidT &gt;::getClosestAfter </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>statetime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the closest after a specific time instant or an invalid object if the request cannot be satisfied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>The time where we want to get the value at </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>shared pointer of the object. </dd></dl>

</div>
</div>
<a class="anchor" id="ad027825ff0a1360acbe6b9c60f708cd9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename PrototypeInvalidT = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;T&gt;&amp; <a class="el" href="classmsf__core_1_1SortedContainer.html">msf_core::SortedContainer</a>&lt; T, PrototypeInvalidT &gt;::getClosestBefore </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>statetime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the closest object before a specific time instant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Time</td><td>the time where we want to get the value at. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>shared pointer of the object. </dd></dl>

</div>
</div>
<a class="anchor" id="a7cce297c5a4bbf80d617741fe3dc902e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename PrototypeInvalidT = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;T&gt;&amp; <a class="el" href="classmsf__core_1_1SortedContainer.html">msf_core::SortedContainer</a>&lt; T, PrototypeInvalidT &gt;::getFirst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the first object in the container or an invalid object if the container is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>shared pointer of the object. </dd></dl>

</div>
</div>
<a class="anchor" id="a9c72942ce59c634559fe7e226b6ab302"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename PrototypeInvalidT = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;T&gt;&amp; <a class="el" href="classmsf__core_1_1SortedContainer.html">msf_core::SortedContainer</a>&lt; T, PrototypeInvalidT &gt;::getInvalid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>To be called to signal that a request could not be satisfied. </p>
<dl class="section return"><dt>Returns</dt><dd>an object of the "invalid" type </dd></dl>

</div>
</div>
<a class="anchor" id="a3ca27ff6fae8916a88a6690b9c8365a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename PrototypeInvalidT = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ListT::iterator <a class="el" href="classmsf__core_1_1SortedContainer.html">msf_core::SortedContainer</a>&lt; T, PrototypeInvalidT &gt;::getIteratorAtValue </td>
          <td>(</td>
          <td class="paramtype">const shared_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>warnIfNotExistant</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the iterator at the specific time instant of the supplied object or an invalid object if the request cannot be satisfied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to get the iterator for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator. </dd></dl>

</div>
</div>
<a class="anchor" id="a727a60e4eb00ab45b2a39c8c069d2fcf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename PrototypeInvalidT = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ListT::iterator <a class="el" href="classmsf__core_1_1SortedContainer.html">msf_core::SortedContainer</a>&lt; T, PrototypeInvalidT &gt;::getIteratorAtValue </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>warnIfNotExistant</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the iterator at a specific time instant or an invalid object if the request cannot be satisfied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>The time where we want to get an iterator at. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator. </dd></dl>

</div>
</div>
<a class="anchor" id="a64ce9fdfdd6220f78187e7270f689f02"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename PrototypeInvalidT = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ListT::iterator <a class="el" href="classmsf__core_1_1SortedContainer.html">msf_core::SortedContainer</a>&lt; T, PrototypeInvalidT &gt;::getIteratorClosest </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>statetime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the iterator closest to a specific time instant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>The time where we want to get an iterator at. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator. </dd></dl>

</div>
</div>
<a class="anchor" id="a3c1f848e9874f9bdc4ab12645e699fcf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename PrototypeInvalidT = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ListT::iterator <a class="el" href="classmsf__core_1_1SortedContainer.html">msf_core::SortedContainer</a>&lt; T, PrototypeInvalidT &gt;::getIteratorClosestAfter </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>statetime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the iterator closest after a specific time instant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>The time where we want to get an iterator at. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator. </dd></dl>

</div>
</div>
<a class="anchor" id="a4cbd2aeae2f6dde2dfd0dceea4a8e928"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename PrototypeInvalidT = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ListT::iterator <a class="el" href="classmsf__core_1_1SortedContainer.html">msf_core::SortedContainer</a>&lt; T, PrototypeInvalidT &gt;::getIteratorClosestBefore </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>statetime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the iterator closest before a specific time instant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>The time where we want to get an iterator at. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator. </dd></dl>

</div>
</div>
<a class="anchor" id="ada83f9baa4b17b5816975b1e67354ff1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename PrototypeInvalidT = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;T&gt;&amp; <a class="el" href="classmsf__core_1_1SortedContainer.html">msf_core::SortedContainer</a>&lt; T, PrototypeInvalidT &gt;::getLast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the last object in the container or an invalid object if the container is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>shared pointer of the object. </dd></dl>

</div>
</div>
<a class="anchor" id="aa0de5fa4d79a266a36556b67252a7d34"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename PrototypeInvalidT = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;T&gt;&amp; <a class="el" href="classmsf__core_1_1SortedContainer.html">msf_core::SortedContainer</a>&lt; T, PrototypeInvalidT &gt;::getValueAt </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>statetime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the object at a specific time instant or an invalid object if the request cannot be satisfied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>The time where we want to get the value at. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>shared pointer of the object. </dd></dl>

</div>
</div>
<a class="anchor" id="af51c989973b49002e737190cec67b6b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename PrototypeInvalidT = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ListT::size_type <a class="el" href="classmsf__core_1_1SortedContainer.html">msf_core::SortedContainer</a>&lt; T, PrototypeInvalidT &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the internal container. </p>
<dl class="section return"><dt>Returns</dt><dd>Size of the container. </dd></dl>

</div>
</div>
<a class="anchor" id="a7e4c594bb1aec9d6d4d8fb73e7baff9a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename PrototypeInvalidT = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt;T&gt; <a class="el" href="classmsf__core_1_1SortedContainer.html">msf_core::SortedContainer</a>&lt; T, PrototypeInvalidT &gt;::updateTime </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeOld</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeNew</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function updates the time of an object in the container this function effectively changes the map ordering, so the previous iterators are invalidated the attribute unused can be eliminated for non gcc compilers, its just a little more verbose in cases where the updated value is not used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeOld</td><td>The time of the value to update. </td></tr>
    <tr><td class="paramname">timeNew</td><td>The time to update to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>shared pointer of the object. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>msf_core/include/msf_core/<a class="el" href="msf__sortedContainer_8h_source.html">msf_sortedContainer.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Nov 6 2013 21:53:36 for msf - modular sensor fusion by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
